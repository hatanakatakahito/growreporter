import { NextRequest, NextResponse } from 'next/server';
import { AdminFirestoreService } from '@/lib/firebase/adminFirestore';
import { decryptTokens, isEncrypted } from '@/lib/security/encryption';

export async function GET(request: NextRequest) {
  try {
    const userId = request.headers.get('x-user-id');
    const siteUrl = request.nextUrl.searchParams.get('siteUrl');
    const startDate = request.nextUrl.searchParams.get('startDate') || '30daysAgo';
    const endDate = request.nextUrl.searchParams.get('endDate') || 'today';

    console.log('ğŸ“Š GSC ã‚¯ã‚¨ãƒªãƒ‡ãƒ¼ã‚¿å–å¾—é–‹å§‹:', { userId, siteUrl, startDate, endDate });

    if (!userId || !siteUrl) {
      return NextResponse.json(
        { error: 'Missing required parameters' },
        { status: 400 }
      );
    }

    // OAuth ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
    const tokensDoc = await AdminFirestoreService.getOAuthTokens(userId, 'google');

    if (!tokensDoc || !tokensDoc.unified) {
      console.error('âŒ OAuth tokens not found for user:', userId);
      return NextResponse.json(
        { error: 'OAuth tokens not found. Please reconnect your Google account.' },
        { status: 401 }
      );
    }

    let accessToken = '';
    let refreshToken = '';
    let expiresAt = 0;

    if (isEncrypted(tokensDoc.unified)) {
      console.log('ğŸ”“ ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å¾©å·åŒ–ä¸­...');
      const decrypted = decryptTokens(tokensDoc.unified);
      accessToken = decrypted.accessToken;
      refreshToken = decrypted.refreshToken;
      expiresAt = decrypted.expiresAt;
    } else {
      accessToken = tokensDoc.unified.accessToken;
      refreshToken = tokensDoc.unified.refreshToken;
      expiresAt = tokensDoc.unified.expiresAt;
    }

    // expiresAtã®å‹å¤‰æ›
    let expiresAtMs = 0;
    if (expiresAt) {
      if (typeof expiresAt === 'object' && expiresAt !== null) {
        if ('toMillis' in expiresAt && typeof (expiresAt as any).toMillis === 'function') {
          expiresAtMs = (expiresAt as any).toMillis();
        } else if ('seconds' in expiresAt) {
          expiresAtMs = (expiresAt as any).seconds * 1000;
        }
      } else if (typeof expiresAt === 'number') {
        expiresAtMs = expiresAt;
      }
    }

    const now = Date.now();

    // ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™ã‚’ãƒã‚§ãƒƒã‚¯
    if (expiresAtMs < now) {
      console.log('âš ï¸ ãƒˆãƒ¼ã‚¯ãƒ³æœŸé™åˆ‡ã‚Œ - ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥é–‹å§‹');

      const clientId = process.env.NEXT_PUBLIC_GOOGLE_UNIFIED_CLIENT_ID;
      const clientSecret = process.env.GOOGLE_UNIFIED_CLIENT_SECRET;

      const refreshResponse = await fetch('https://oauth2.googleapis.com/token', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: new URLSearchParams({
          client_id: clientId!,
          client_secret: clientSecret!,
          refresh_token: refreshToken,
          grant_type: 'refresh_token',
        }),
      });

      if (!refreshResponse.ok) {
        throw new Error('Failed to refresh OAuth token. Please reconnect your Google account.');
      }

      const refreshData = await refreshResponse.json();
      accessToken = refreshData.access_token;
      const newExpiresAt = Date.now() + refreshData.expires_in * 1000;

      await AdminFirestoreService.updateAccessToken(userId, 'google', accessToken, newExpiresAt);
      console.log('âœ… ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã—ã¾ã—ãŸ');
    }

    // Search Console API ã‚’å‘¼ã³å‡ºã—
    const apiUrl = `https://www.googleapis.com/webmasters/v3/sites/${encodeURIComponent(siteUrl)}/searchAnalytics/query`;

    const requestBody = {
      startDate,
      endDate,
      dimensions: ['query'],
      rowLimit: 100,
    };

    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('âŒ GSC API ã‚¨ãƒ©ãƒ¼:', errorText);
      throw new Error(`GSC API request failed: ${response.status}`);
    }

    const data = await response.json();

    // ãƒ‡ãƒ¼ã‚¿ã‚’æ•´å½¢
    // GSC APIã‹ã‚‰å–å¾—ã—ãŸCTRã¯0-1ã®ç¯„å›²ãªã®ã§ã€ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸è¡¨ç¤ºã®ãŸã‚ã«100å€ã™ã‚‹
    const queries = data.rows?.map((row: any) => ({
      query: row.keys[0],
      clicks: row.clicks || 0,
      impressions: row.impressions || 0,
      ctr: row.ctr || 0, // GSC APIã‹ã‚‰ã®CTRå€¤ã‚’ãã®ã¾ã¾ä¿å­˜ï¼ˆ0-1ã®ç¯„å›²ï¼‰
      position: row.position || 0,
    })) || [];

    console.log('âœ… GSC ã‚¯ã‚¨ãƒªãƒ‡ãƒ¼ã‚¿å–å¾—æˆåŠŸ:', queries.length, 'ä»¶');
    if (queries.length > 0) {
      console.log('ğŸ“Š ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿:', {
        query: queries[0].query,
        clicks: queries[0].clicks,
        impressions: queries[0].impressions,
        ctr: queries[0].ctr,
        ctrPercent: (queries[0].ctr * 100).toFixed(2) + '%',
        position: queries[0].position
      });
    }

    return NextResponse.json({ queries });

  } catch (error: any) {
    console.error('âŒ GSC ã‚¯ã‚¨ãƒªãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
    return NextResponse.json(
      { error: 'Failed to fetch GSC query data', message: error.message },
      { status: 500 }
    );
  }
}

